/*
	셸 정렬이란...

	단순 삽입 정렬의 장점은 살리고, 단점은 보완
	
	** 단순 삽입 정렬의 특징 **
	장점. 정렬을 마쳤거나 정렬을 마친 상태에 가까우면 정렬 속도가 매우 빨라짐
	단점. 삽입할 위치가 멀리 떨어져 있으면 이동해야하는 횟수가 많아짐

	이걸 보완한 정렬이 셸 정렬이다.
	
	예를 들어, [1, 2, 3, 4, 5, 6, 7, 8] 이렇게 8 개의 배열이 있으면,
	[1, 5], [2, 6], [3, 7], [4, 8] 이렇게 4개의 배열로 나눠서 정렬을 하고,
	다시 [1, 3, 5, 7], [2, 4, 6, 8] 2개의 배열로 나눠서 정렬을 하고,
	[1, 2, 3, 4, 5, 6, 7, 8] 1개의 배열로 정렬.

	다시 [8, 1, 4, 2, 7, 6, 3, 5] 라면,
	[8, 7], [1, 6], [4, 3], [2, 5] 이렇게 4개의 배열로 나눠서 정렬 후
	[7, 8], [1, 6], [3, 4], [2, 5] 정렬 후 다시 합침.
	[7, 1, 4, 2, 8, 6, 3, 5] 로 정렬 후
	[7, 4, 8, 3], [1, 2, 6, 5] 를 다시 정렬 => [3, 4, 7, 8], [1, 2, 5, 6]
	[3, 1, 4, 2, 7, 5, 8, 6]
	[

*/
#include <stdio.h>
#include <stdlib.h>


/*
	홀수, 짝수 정렬 후?
	간격?
*/
void myshell(int a[], int n)
{
	int interval = 0;
	interval = n / 2;
	while (interval > 0) {
		
	}
}



























void shell(int a[], int n)
{
	int i, j, h;
	for (h = n / 2; h > 0; h /= 2)
		for (i = h; i < n; i++) {
			int tmp = a[i];
			for (j = i - h; j >= 0 && a[j] > tmp; j -= h)
				a[j + h] = a[j];
			a[j + h] = tmp;
		}
}